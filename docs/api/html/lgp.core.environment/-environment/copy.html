<HTML>
<HEAD>
<meta charset="UTF-8">
<title>Environment.copy - </title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">lgp.core.environment</a>&nbsp;/&nbsp;<a href="index.html">Environment</a>&nbsp;/&nbsp;<a href="./copy.html">copy</a><br/>
<br/>
<h1>copy</h1>
<a name="lgp.core.environment.Environment$copy()"></a>
<code><span class="keyword">fun </span><span class="identifier">copy</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><a href="index.html"><span class="identifier">Environment</span></a><span class="symbol">&lt;</span><a href="index.html#TProgram"><span class="identifier">TProgram</span></a><span class="symbol">,</span>&nbsp;<a href="index.html#TOutput"><span class="identifier">TOutput</span></a><span class="symbol">&gt;</span></code>
<p>Produces a clone of the current environment.</p>
<p>It should be noted that because an environment instance has its own RNG associated with it,
when making a copy, it is required that the copied environment have its own RNG too.
To fulfil this requirement, when an environment is copied, it will initialise a new RNG that is
seeded with a seed given from the RNG of the environment instance performing the copy (confusing -- yes!).</p>
<p>The main reason behind this complication is to ensure that there are no contention issues when multiple
environment instances are operating in a multi-threaded context (e.g. through a <a href="#">lgp.core.evolution.Trainers.DistributedTrainer</a>).</p>
<p>Furthermore, any modules that are registered with the environment being copied, will be updated so
that the reference the correct environment instance (i.e. the copy). This ensures that while the
module registrations themselves are shared between copies, when a module is accessed, it gets initialised
correctly.</p>
<p><strong>Return</strong><br/>
A new <a href="index.html">Environment</a> instance that is a copy of that the method is called on.</p>
</BODY>
</HTML>
